/* Copyright 2018 kevin Lau (http://github.com/stormycatcat)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#ifndef _STDLIB_TYPE_TRAITS_
#define _STDLIB_TYPE_TRAITS_

#include <cstddef>

namespace std
{

template <class T,T v>
struct integral_constant
{
    using value_type=T;
    using type=integral_constant;
    static constexpr T value=v;
    constexpr operator value_type()const noexcept{return value;}
    constexpr value_type operator()()const noexcept{return value;}
};


template <bool B>
using bool_constant=integral_constant<bool,B>;


using true_type=integral_constant<bool,true>;
using false_type=integral_constant<bool,false>;


template <class T>
struct is_void : public false_type {};

template <>
struct is_void<void> : public true_type {};

template <>
struct is_void<const void> : public true_type {};

template <>
struct is_void<volatile void> : public true_type {};

template <>
struct is_void<const volatile void> : public true_type {};


template <class T>
struct is_null_pointer : public false_type {};

template <>
struct is_null_pointer<nullptr_t> : public true_type {};

template <>
struct is_null_pointer<const nullptr_t> : public true_type {};

template <>
struct is_null_pointer<volatile nullptr_t> : public true_type {};
template <>
struct is_null_pointer<const volatile nullptr_t> : public true_type {};

template<class T>
struct is_integral : public false_type {};

template<>
struct is_integral<bool> : public true_type {};

template<>
struct is_integral<char> : public true_type {};

template<>
struct is_integral<char16_t> : public true_type {};

template<>
struct is_integral<char32_t> : public true_type {};

template<>
struct is_integral<wchar_t> : public true_type {};

template<>
struct is_integral<short> : public true_type {};

template<>
struct is_integral<int> : public true_type {};

template<>
struct is_integral<long> : public true_type {};

template<>
struct is_integral<long long> : public true_type {};


template<class T>
struct is_floating_point : public false_type {};

template<>
struct is_floating_point<float> : public true_type {};

template<>
struct is_floating_point<double> : public true_type {};

template<>
struct is_floating_point<long double> : public true_type {};


template<class T>
struct is_array : public false_type {};

template<class T>
struct is_array<T[]> : public true_type {};

template<class T,size_t N>
struct is_array<T[N]> : public true_type {};


template<class T>
struct is_pointer : public false_type {};

template<class T>
struct is_pointer<T*> : public true_type {};


#ifdef __GNUC__
template<class T>
struct is_union : public integral_constant<bool,__is_union(T)> {};
#else
#endif


#ifdef __GNUC__
template<class T>
struct is_enum : public integral_constant<bool,__is_enum(T)> {};
#else
template<class T>
struct is_enum : public integral_constant<bool, 
    !is_void<T>::value&&
    !is_integral<T>::value&&
    !is_null_pointer<T>::value&&
    !is_floating_point<T>::value&&
    !is_array<T>::value&&
    !is_pointer<T>::value&&
    !is_reference<T>::value&&
    !is_member_pointer<T>::value&&
    !is_union<T>::value&&
    !is_class<T>::value&&
    !is_function<T>::value
> {};
#endif

}

#endif
